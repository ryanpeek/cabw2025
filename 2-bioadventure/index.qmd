---
title: Bioassessment Data Adventure
engine: knitr
format: 
  live-html:
      toc: true
webr:
  render-df: gt-interactive
  packages:
    - dplyr
    - tidyr
    - ggplot2
    - janitor
  cell-options:
    min-lines: 6
    editor-font-scale: 0.8
    fig-width: 7
    fig-height: 4.3
    out-width: "100%"
editor_options: 
  chunk_output_type: console
---

{{< include ../_extensions/r-wasm/live/_knitr.qmd >}}


The general approach here can be to join tables (need to update site locations to include the county so as to avoid needing sf and tigris).

Join tables, summarize by county, find county with highest CSCI scores and county with lowest CSCI scores.

Generate a quick box plot comparison by county

Look at trend latitudinally 

Generate summary table of stations to monitor

Find counties with fewest stations and identify sampling gaps

## Import our Data

First off we want to import our data so we can use it. For this data adventure, let's import three pieces, the `CSCI` values, the `ASCI` values, and a corresponding latitude & longitude list of our stations. We can then integrate all these pieces.

```{webr}

csci_url <- "https://raw.githubusercontent.com/ryanpeek/cabw2025/refs/heads/main/data/cscidat.csv"
cscidat <- read.csv(csci_url)
str(cscidat)

asci_url <- "https://raw.githubusercontent.com/ryanpeek/cabw2025/refs/heads/main/data/ascidat.csv"
ascidat <- read.csv(csci_url)

latlons <- read.csv(file =  "https://raw.githubusercontent.com/ryanpeek/cabw2025/refs/heads/main/data/latlon.csv")

glimpse(latlons)


```

## Selecting and Filtering

A big part of working with data is figuring out how to  `select`, `filter`, `slice`,, and `summarize`our data into the pieces we want. The good news is each of these things is a function in the {dplyr} package, so we can walk through a few examples for each of these *verbs*.

### `select`

We `select` columns. There are many options we can use to select the columns we want. Here are a few options, but there are many! Remember, we need to have loaded our `dplyr` package first. 

::: {.callout-tip}
## ðŸ“£ To "Quote" or not to Quote

One difficult thing to be aware of in R is when and where we use quotation marks. For the most part, calling column names in dplyr does **Not* require quoting. However, if we are using specific values, these typically need to be "quoted". Stay tuned for more!

:::

```{webr}
# first, select some columns
sel_1 <- select(
  # first the data
  .data = cscidat,
  # next the columns we want
  SampleID_old, New_Lat, New_Long, CSCI) 

glimpse(sel_1)
```

Try selecting everything but a few columns. Let's select all *but* `CSCI` and `COMID`

```{webr}

sel_2 <- select(cscidat, -CSCI, -COMID)
names(sel_2)

# another way to write this is using "c(CSCI, COMID)"
# however we need to put the "-" in front 
sel_2 <- select(cscidat, -c(CSCI, COMID))

```

Or we can select a columns that start with `"New"`

```{webr}
# select columns that start with "New"
sel_3 <- select(cscidat, starts_with('New'))

# or same sort of thing
sel_3 <- select(cscidat, contains('New'))
head(sel_3)

```

### `filter`

We `filter` **rows**. After we select some columns, youâ€™ll probably want to remove observations that donâ€™t fit some criteria. For example, maybe you want to remove CSCI scores less than some threshold, or find stations above a certain latitude, or both.

```{webr}

# get CSCI scores greater than 0.79
filt_1 <- filter(cscidat, CSCI > 0.79)

summary(filt_1$CSCI)

# get CSCI scores above latitude 37N
filt_2 <- filter(cscidat, New_Lat > 37)
summary(filt_2$New_Lat)

```

We can chain these together. In `filter()`, there are many ways to do this, but be aware if we use a `,` to separate different filters, it is treated as **`and`**. So both arguments must be met. For an either / or filter, we'd want to use a vertical bar, `|` separating our arguments.

```{webr}

# get CSCI scores above latitude 37N
filt_3 <- filter(cscidat, New_Lat > 37, CSCI > 0.79)

select(filt_3, New_Lat, CSCI) |> summary()

```

::: {.callout-tip}
## ðŸ“£ Chaining or Piping (`%>%` or `|>`)

We can chain code together by using a pipe argument (`%>%` or `|>`). These can be viewed as passing whatever is coming from the left side, on to the right side. Think of this as doing an operation on an object, pass to the pipe (`|>`) **and then** doing another operation. 

So, above, we select columns from our filtered dataset, **and then** we summarize those columns.

:::

### `slice`

`slice` is another function in the `{dplyr}` package, which allows us to do additional filtering of data based on values or summarizing actions. Here we'll use it to find the top ten CSCI values, but it is a powerful function with many uses, and can be easily chained together with other functions like `filter` and `select`.

```{webr}

# get top 10 highest CSCI scores 
csci_top_10 <- slice_max(cscidat, order_by = CSCI, n = 10)

# now get bottom 10 and select only the Station Code and CSCI score
csci_bot_10 <- slice_min(cscidat, order_by=CSCI, n=10) |> 
  select(StationCode, CSCI)

```

::: {.callout-tip}

## ðŸ“£ Binding data frames
Remember, a vector is essentially a *column* of a single type of data. And data frames have to have columns with the same number of rows. So when binding rows, they need to be the same data `class` in each column, and when binding columns, they must have the same number of rows as the data frame. 

:::


## Renaming

Often times we need to rename our columns in order to make joining data easier, or for tables and plots that we want to share out. There are a few ways to rename columns in R.

We can use the `dplyr::rename()` function to specifically rename columns of interest. This requires the data, and a list of the columns we are interested in changing, formatted as: `new_name` = `old_name`.

```{webr}

# rename with dplyr
cscidat_lower <- rename(cscidat, 
              id = SampleID_old, 
              lat = New_Lat, 
              lon = New_Long)
names(cscidat_lower)
```

Another great tool is the `{janitor}` package. We can use a number of functions in janitor, but most commonly I use it to clean all the column names. 

```{webr}

# rename all columns with janitor
cscidat_janitor <- janitor::clean_names(cscidat)
names(cscidat_janitor)

# take a look at options in the clean_names() function
# how can we change the case to inital caps?
# hint: help("clean_names")

```


## Modifying and Summarizing Data

When we want to add, revise, or summarize our data, we need to use a few additional functions in `{dplyr}`. We can use these to create new columns, calculate new data based on existing data, or create summaries based on different groups within our data.

### `mutate` (adding columns)

Weâ€™ve seen how to `filter` observations (rows) and `select` columns of a data frame. In `{dplyr}`, `mutate` allows us to add new columns to an existing data frame. These can be vectors you are adding or based on expressions applied to existing columns. For instance, maybe we want to convert a numeric column into a categorical using some criteria or maybe we want to make a new column based on some arithmetic on some other columns.

```{webr}

# get observed taxa
mut_1 <- mutate(cscidat, observed = OE * E)

glimpse(mut_1)

# add a column for lo/hi csci scores
mut_2 <- mutate(mut_1, CSCIcat = ifelse(CSCI <= 0.79, 'lo', 'hi'))
glimpse(mut_2)

```


### `bind` Data

Sometimes when we don't need to worry about joining specifically, and we want to append or mash datasets together, we can use the **bind** functions. There are base options as well as `{dplyr}` options. Let's revisit the `slice` function we used above, and make a new dataframe that is just the *StationCode*, *CSCI*, and *Lat* and *Lon* for the top 10 and bottom 10 CSCI values. We can bind rows, or bind columns, depending on what we are trying to do.

```{webr}
# get top 10 highest CSCI scores 
csci_top_10 <- slice_max(cscidat, order_by = CSCI, n = 10) |>   select(StationCode, CSCI, New_Lat, New_Long)

# now get bottom 10
csci_bot_10 <- slice_min(cscidat, order_by=CSCI, n=10) |> 
    select(StationCode, CSCI, New_Lat, New_Long)

# now BIND!
csci_top_bottom <- bind_rows(csci_top_10, csci_bot_10)
csci_top_bottom

```

## Joining

Combining data is a common task of data wrangling. All joins require that each of the tables can be linked by shared identifiers. These are called â€˜keysâ€™ and are usually represented as a separate column that acts as a unique variable for the observations. Our example datasets include the id column that represents a unique identifier as a combination of station, sample date, and replicate.

The challenge with joins is that the two datasets may not represent the same observations for a given key. For example, you might have one table with all observations for every key, another with only some observations, or two tables with only a few shared keys. What you get back from a join will depend on whatâ€™s shared between tables, in addition to the type of join you use.

For our data, weâ€™ll be using an **`inner_join`** that combines datasets by shared keys (for an overview of the other types of joins, see [R4DS lesson here](https://r4ds.had.co.nz/relational-data.html#mutating-joins).

![Figures by Garrick Adenbuie, see [here for more](https://www.garrickadenbuie.com/project/tidyexplain/)](https://raw.githubusercontent.com/gadenbuie/tidyexplain/main/images/inner-join.gif)


```{webr}
alldat <- inner_join(cscidat, ascidat, by = 'id')
```

